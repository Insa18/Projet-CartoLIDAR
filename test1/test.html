<!DOCTYPE html>
<html lang="fr">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>D√©tection RANSAC - L √âpais et Creux</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/plotly.js/2.26.0/plotly.min.js"></script>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: #333;
            min-height: 100vh;
        }

        .container {
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 30px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            backdrop-filter: blur(10px);
        }

        h1 {
            text-align: center;
            color: #2c3e50;
            margin-bottom: 30px;
            font-size: 2.2em;
            font-weight: 300;
            text-shadow: 2px 2px 4px rgba(0,0,0,0.1);
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(280px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
            padding: 25px;
            background: rgba(116, 75, 162, 0.1);
            border-radius: 15px;
            border: 2px solid rgba(116, 75, 162, 0.2);
        }

        .control-section {
            padding: 20px;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 12px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .section-title {
            font-size: 1.1em;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 15px;
            text-align: center;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 2px solid #667eea;
            padding-bottom: 8px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            margin-bottom: 15px;
        }

        label {
            font-weight: 600;
            margin-bottom: 8px;
            color: #2c3e50;
            font-size: 0.9em;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        input[type="number"], input[type="range"] {
            padding: 10px;
            border: 2px solid #e1e8ed;
            border-radius: 8px;
            font-size: 14px;
            transition: all 0.3s ease;
        }

        input[type="number"]:focus, input[type="range"]:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .range-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .range-value {
            min-width: 60px;
            text-align: center;
            background: rgba(102, 126, 234, 0.1);
            padding: 5px 10px;
            border-radius: 5px;
            font-weight: bold;
            color: #2c3e50;
        }

        button {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 18px 40px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 18px;
            font-weight: 600;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 8px 20px rgba(102, 126, 234, 0.3);
            width: 100%;
            margin-bottom: 20px;
        }

        button:hover {
            transform: translateY(-2px);
            box-shadow: 0 12px 25px rgba(102, 126, 234, 0.4);
        }

        button:active {
            transform: translateY(0);
        }

        #plot {
            background: white;
            border-radius: 15px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.1);
            overflow: hidden;
            min-height: 600px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-top: 20px;
            padding: 20px;
            background: rgba(102, 126, 234, 0.1);
            border-radius: 15px;
            border: 2px solid rgba(102, 126, 234, 0.2);
        }

        .stat-item {
            text-align: center;
            padding: 15px;
            background: white;
            border-radius: 10px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .stat-label {
            font-size: 0.8em;
            color: #666;
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 5px;
        }

        .stat-value {
            font-size: 1.4em;
            font-weight: bold;
            color: #2c3e50;
        }

        .segment-colors {
            display: flex;
            flex-wrap: wrap;
            gap: 8px;
            margin-top: 10px;
            justify-content: center;
        }

        .color-indicator {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.2);
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç D√©tection RANSAC - L √âpais et Creux</h1>
        
        <div class="controls">
            <div class="control-section">
                <div class="section-title">üèóÔ∏è Dimensions du L</div>
                <div class="control-group">
                    <label>Longueur bras horizontal</label>
                    <div class="range-container">
                        <input type="range" id="lengthH" min="8" max="20" value="15">
                        <span class="range-value" id="lengthHValue">15</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Longueur bras vertical</label>
                    <div class="range-container">
                        <input type="range" id="lengthV" min="8" max="20" value="12">
                        <span class="range-value" id="lengthVValue">12</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>√âpaisseur du L</label>
                    <div class="range-container">
                        <input type="range" id="thickness" min="2" max="6" step="0.5" value="3">
                        <span class="range-value" id="thicknessValue">3</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">üìä Points et Bruit</div>
                <div class="control-group">
                    <label>Points par segment</label>
                    <div class="range-container">
                        <input type="range" id="pointsPerSegment" min="20" max="100" value="50">
                        <span class="range-value" id="pointsPerSegmentValue">50</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Niveau de bruit</label>
                    <div class="range-container">
                        <input type="range" id="noiseLevel" min="0.05" max="0.5" step="0.05" value="0.15">
                        <span class="range-value" id="noiseLevelValue">0.15</span>
                    </div>
                </div>
            </div>

            <div class="control-section">
                <div class="section-title">üéØ Param√®tres RANSAC</div>
                <div class="control-group">
                    <label>Seuil de distance</label>
                    <div class="range-container">
                        <input type="range" id="ransacThreshold" min="0.3" max="2.0" step="0.1" value="0.8">
                        <span class="range-value" id="ransacThresholdValue">0.8</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>It√©rations max</label>
                    <div class="range-container">
                        <input type="range" id="ransacIterations" min="500" max="3000" step="250" value="1500">
                        <span class="range-value" id="ransacIterationsValue">1500</span>
                    </div>
                </div>
                <div class="control-group">
                    <label>Min inliers (%)</label>
                    <div class="range-container">
                        <input type="range" id="minInliers" min="10" max="50" value="25">
                        <span class="range-value" id="minInliersValue">25</span>
                    </div>
                </div>
            </div>
        </div>
        
        <button onclick="generateAndDetect()">üöÄ G√©n√©rer L √âpais et D√©tecter Segments</button>
        
        <div id="plot"></div>
        
        <div class="stats" id="stats" style="display: none;">
            <div class="stat-item">
                <div class="stat-label">Points total</div>
                <div class="stat-value" id="totalPoints">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Segments d√©tect√©s</div>
                <div class="stat-value" id="segmentsDetected">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Taux de r√©ussite</div>
                <div class="stat-value" id="successRate">-</div>
            </div>
            <div class="stat-item">
                <div class="stat-label">Inliers moyens</div>
                <div class="stat-value" id="avgInliers">-</div>
            </div>
        </div>
    </div>

    <script>
        // Couleurs pour chaque segment
        const SEGMENT_COLORS = [
            '#e74c3c', // Rouge
            '#3498db', // Bleu
            '#2ecc71', // Vert
            '#f39c12', // Orange
            '#9b59b6', // Violet
            '#1abc9c'  // Turquoise
        ];

        // Mise √† jour des valeurs affich√©es pour les sliders
        function updateSliderValues() {
            const sliders = [
                'lengthH', 'lengthV', 'thickness', 'pointsPerSegment', 
                'noiseLevel', 'ransacThreshold', 'ransacIterations', 'minInliers'
            ];
            
            sliders.forEach(id => {
                const element = document.getElementById(id);
                const valueElement = document.getElementById(id + 'Value');
                if (element && valueElement) {
                    valueElement.textContent = element.value;
                }
            });
        }

        // Event listeners pour les sliders
        document.querySelectorAll('input[type="range"]').forEach(slider => {
            slider.addEventListener('input', updateSliderValues);
        });

        // G√©n√©rateur de nombres al√©atoires gaussiens (Box-Muller)
        function gaussianRandom(mean = 0, std = 1) {
            let u = 0, v = 0;
            while(u === 0) u = Math.random();
            while(v === 0) v = Math.random();
            const z = Math.sqrt(-2 * Math.log(u)) * Math.cos(2 * Math.PI * v);
            return z * std + mean;
        }

        // G√©n√©ration d'un segment avec bruit
        function generateSegmentPoints(startPoint, endPoint, numPoints, noiseLevel) {
            const points = [];
            const [x1, y1] = startPoint;
            const [x2, y2] = endPoint;
            
            for (let i = 0; i < numPoints; i++) {
                const t = i / (numPoints - 1);
                const baseX = x1 + t * (x2 - x1);
                const baseY = y1 + t * (y2 - y1);
                
                // Ajouter du bruit gaussien simple dans toutes les directions
                const noiseX = gaussianRandom(0, noiseLevel);
                const noiseY = gaussianRandom(0, noiseLevel);
                
                const noisyX = baseX + noiseX;
                const noisyY = baseY + noiseY;
                
                points.push([noisyX, noisyY]);
            }
            
            return points;
        }

        // G√©n√©ration de la forme en L √©pais et creux
        function generateThickLPoints(lengthH, lengthV, thickness, pointsPerSegment, noiseLevel) {
            const segments = [];
            const allPoints = [];
            
            // D√©finir les 6 segments du L √©pais
            const segmentDefinitions = [
                // Bord ext√©rieur horizontal bas
                [[0, 0], [lengthH, 0]],
                // Bord ext√©rieur vertical droit
                [[lengthH, 0], [lengthH, thickness]],
                // Bord int√©rieur horizontal haut (partie courte)
                [[lengthH, thickness], [thickness, thickness]],
                // Bord int√©rieur vertical gauche
                [[thickness, thickness], [thickness, lengthV]],
                // Bord ext√©rieur horizontal haut
                [[thickness, lengthV], [0, lengthV]],
                // Bord ext√©rieur vertical gauche
                [[0, lengthV], [0, 0]]
            ];
            
            // G√©n√©rer les points pour chaque segment
            segmentDefinitions.forEach((segDef, index) => {
                const segmentPoints = generateSegmentPoints(
                    segDef[0], segDef[1], pointsPerSegment, noiseLevel
                );
                
                const segment = {
                    points: segmentPoints,
                    startPoint: segDef[0],
                    endPoint: segDef[1],
                    index: index
                };
                
                segments.push(segment);
                allPoints.push(...segmentPoints);
            });
            
            return { segments, allPoints };
        }

        // Distance d'un point √† une ligne d√©finie par ax + by + c = 0
        function distancePointToLine(point, line) {
            const [x, y] = point;
            const [a, b, c] = line;
            return Math.abs(a * x + b * y + c) / Math.sqrt(a * a + b * b);
        }

        // Calcul de la ligne passant par deux points (forme ax + by + c = 0)
        function lineFromTwoPoints(p1, p2) {
            const [x1, y1] = p1;
            const [x2, y2] = p2;
            
            if (Math.abs(x2 - x1) < 1e-10) {
                // Ligne verticale: x = x1
                return [1, 0, -x1];
            } else if (Math.abs(y2 - y1) < 1e-10) {
                // Ligne horizontale: y = y1
                return [0, 1, -y1];
            } else {
                // Ligne g√©n√©rale
                const a = y2 - y1;
                const b = x1 - x2;
                const c = (x2 - x1) * y1 - (y2 - y1) * x1;
                return [a, b, c];
            }
        }

        // Algorithme RANSAC pour d√©tecter une ligne
        function ransacLine(points, threshold, maxIterations, minInliersPercent) {
            if (points.length < 2) return null;
            
            let bestLine = null;
            let bestInliers = [];
            let maxInliers = 0;
            const minInliers = Math.max(2, Math.floor(points.length * minInliersPercent / 100));

            for (let iter = 0; iter < maxIterations; iter++) {
                // S√©lectionner 2 points al√©atoirement
                const idx1 = Math.floor(Math.random() * points.length);
                let idx2 = Math.floor(Math.random() * points.length);
                while (idx2 === idx1) {
                    idx2 = Math.floor(Math.random() * points.length);
                }

                const p1 = points[idx1];
                const p2 = points[idx2];

                // V√©rifier que les points ne sont pas trop proches
                const dist = Math.sqrt((p2[0] - p1[0])**2 + (p2[1] - p1[1])**2);
                if (dist < 0.1) continue;

                // Calculer la ligne
                const line = lineFromTwoPoints(p1, p2);
                if (!line) continue;

                // Compter les inliers
                const inliers = [];
                for (let i = 0; i < points.length; i++) {
                    if (distancePointToLine(points[i], line) < threshold) {
                        inliers.push(i);
                    }
                }

                // Garder le meilleur mod√®le
                if (inliers.length > maxInliers) {
                    maxInliers = inliers.length;
                    bestLine = line;
                    bestInliers = inliers;
                }
            }

            // Retourner m√™me si moins d'inliers que le minimum requis, mais au moins 5 points
            return (bestLine && bestInliers.length >= 5) ? { line: bestLine, inliers: bestInliers } : null;
        }

        // G√©n√©ration des points de la ligne pour l'affichage
        function generateLinePoints(line, bounds) {
            const [a, b, c] = line;
            const points = [];
            const { xMin, xMax, yMin, yMax } = bounds;

            if (Math.abs(b) > Math.abs(a)) {
                // Plus horizontal
                for (let x = xMin; x <= xMax; x += 0.1) {
                    const y = -(a * x + c) / b;
                    if (y >= yMin && y <= yMax) {
                        points.push([x, y]);
                    }
                }
            } else {
                // Plus vertical
                for (let y = yMin; y <= yMax; y += 0.1) {
                    const x = -(b * y + c) / a;
                    if (x >= xMin && x <= xMax) {
                        points.push([x, y]);
                    }
                }
            }

            return points;
        }

        // D√©tection it√©rative de tous les segments
        function detectAllSegments(points, threshold, maxIterations, minInliersPercent, maxSegments = 6) {
            const detectedSegments = [];
            let remainingPoints = [...points];
            let remainingIndices = Array.from({length: points.length}, (_, i) => i);

            console.log(`D√©marrage d√©tection avec ${points.length} points, seuil: ${threshold}`);

            for (let segmentCount = 0; segmentCount < maxSegments && remainingPoints.length > 5; segmentCount++) {
                console.log(`Tentative segment ${segmentCount + 1}, points restants: ${remainingPoints.length}`);
                
                const result = ransacLine(remainingPoints, threshold, maxIterations, minInliersPercent);
                
                if (!result) {
                    console.log(`Aucun segment trouv√© √† l'it√©ration ${segmentCount + 1}`);
                    break;
                }

                console.log(`Segment trouv√© avec ${result.inliers.length} inliers`);

                // Convertir les indices locaux en indices globaux
                const globalInliers = result.inliers.map(localIdx => remainingIndices[localIdx]);
                
                detectedSegments.push({
                    line: result.line,
                    inliers: globalInliers,
                    color: SEGMENT_COLORS[segmentCount % SEGMENT_COLORS.length]
                });

                // Retirer les inliers pour la prochaine it√©ration
                const newRemainingPoints = [];
                const newRemainingIndices = [];
                
                for (let i = 0; i < remainingPoints.length; i++) {
                    if (!result.inliers.includes(i)) {
                        newRemainingPoints.push(remainingPoints[i]);
                        newRemainingIndices.push(remainingIndices[i]);
                    }
                }
                
                remainingPoints = newRemainingPoints;
                remainingIndices = newRemainingIndices;
            }

            console.log(`D√©tection termin√©e: ${detectedSegments.length} segments trouv√©s`);
            return detectedSegments;
        }

        // Fonction principale
        function generateAndDetect() {
            // R√©cup√©rer les param√®tres
            const lengthH = parseFloat(document.getElementById('lengthH').value);
            const lengthV = parseFloat(document.getElementById('lengthV').value);
            const thickness = parseFloat(document.getElementById('thickness').value);
            const pointsPerSegment = parseInt(document.getElementById('pointsPerSegment').value);
            const noiseLevel = parseFloat(document.getElementById('noiseLevel').value);
            const threshold = parseFloat(document.getElementById('ransacThreshold').value);
            const maxIterations = parseInt(document.getElementById('ransacIterations').value);
            const minInliersPercent = parseInt(document.getElementById('minInliers').value);

            // G√©n√©rer les points
            const { segments: originalSegments, allPoints } = generateThickLPoints(
                lengthH, lengthV, thickness, pointsPerSegment, noiseLevel
            );

            // D√©tecter les segments avec RANSAC
            const detectedSegments = detectAllSegments(
                allPoints, threshold, maxIterations, minInliersPercent
            );

            // Calculer les bornes pour l'affichage
            const bounds = {
                xMin: -2,
                xMax: lengthH + 2,
                yMin: -2,
                yMax: lengthV + 2
            };

            // Pr√©parer les donn√©es pour Plotly
            const traces = [];

            // Points originaux
            traces.push({
                x: allPoints.map(p => p[0]),
                y: allPoints.map(p => p[1]),
                mode: 'markers',
                type: 'scatter',
                name: 'Points bruit√©s',
                marker: {
                    color: 'rgba(52, 73, 94, 0.6)',
                    size: 4,
                    line: {
                        color: 'rgba(52, 73, 94, 0.8)',
                        width: 1
                    }
                },
                showlegend: true
            });

            // Segments d√©tect√©s
            detectedSegments.forEach((segment, index) => {
                const linePoints = generateLinePoints(segment.line, bounds);
                traces.push({
                    x: linePoints.map(p => p[0]),
                    y: linePoints.map(p => p[1]),
                    mode: 'lines',
                    type: 'scatter',
                    name: `Segment ${index + 1} (${segment.inliers.length} pts)`,
                    line: {
                        color: segment.color,
                        width: 5
                    }
                });
            });

            // Configuration du graphique
            const layout = {
                title: {
                    text: `L √âpais D√©tect√© - ${detectedSegments.length}/6 segments trouv√©s`,
                    font: { size: 20, color: '#2c3e50' }
                },
                xaxis: {
                    title: 'X',
                    range: [bounds.xMin, bounds.xMax],
                    gridcolor: 'rgba(0,0,0,0.1)',
                    zerolinecolor: 'rgba(0,0,0,0.3)',
                    scaleanchor: 'y',
                    scaleratio: 1
                },
                yaxis: {
                    title: 'Y',
                    range: [bounds.yMin, bounds.yMax],
                    gridcolor: 'rgba(0,0,0,0.1)',
                    zerolinecolor: 'rgba(0,0,0,0.3)'
                },
                plot_bgcolor: 'rgba(248,249,250,0.8)',
                paper_bgcolor: 'rgba(255,255,255,0)',
                font: { family: 'Segoe UI', color: '#2c3e50' },
                legend: {
                    x: 0.02,
                    y: 0.98,
                    bgcolor: 'rgba(255,255,255,0.9)',
                    bordercolor: 'rgba(0,0,0,0.2)',
                    borderwidth: 1
                }
            };

            const config = {
                responsive: true,
                displayModeBar: true,
                modeBarButtonsToRemove: ['select2d', 'lasso2d', 'autoScale2d']
            };

            Plotly.newPlot('plot', traces, layout, config);

            // Mettre √† jour les statistiques
            const totalInliers = detectedSegments.reduce((sum, seg) => sum + seg.inliers.length, 0);
            const avgInliers = detectedSegments.length > 0 ? Math.round(totalInliers / detectedSegments.length) : 0;
            const successRate = Math.round((detectedSegments.length / 6) * 100);

            document.getElementById('totalPoints').textContent = allPoints.length;
            document.getElementById('segmentsDetected').textContent = `${detectedSegments.length}/6`;
            document.getElementById('successRate').textContent = `${successRate}%`;
            document.getElementById('avgInliers').textContent = avgInliers;
            document.getElementById('stats').style.display = 'block';
        }

        // Initialisation
        updateSliderValues();
        generateAndDetect();
    </script>
</body>
</html>